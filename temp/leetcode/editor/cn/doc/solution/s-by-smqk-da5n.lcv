![image.png](https://pic.leetcode-cn.com/1648468607-TzlVPU-image.png)

### 解题思路

动态规划

### 代码

* java

```java
class Solution {
    public int longestSubarray(int[] nums) {
        int len = nums.length;
        // dp[i][0] 以 nums[i] 结尾且含有一个 0 的最长连续子数组长度
        // dp[i][1] 以 nums[i] 结尾且全为 1 的最长连续子数组长度
        int[][] dp = new int[len][2];
        dp[0][0] = (nums[0] == 0) ? 1 : 0;
        dp[0][1] = nums[0];

        int maxLen = 0;
        for (int i = 1; i < len; i++) {
            if (nums[i] == 0) {
                dp[i][0] = dp[i-1][1] + 1;
                dp[i][1] = 0;
            } else {
                dp[i][0] = dp[i-1][0] + 1;
                dp[i][1] = dp[i-1][1] + 1;
            }

            if(dp[i][0] > maxLen || dp[i][1] > maxLen){
                maxLen = Math.max(dp[i][0], dp[i][1]);
            }
        }

        // 必须要删除一个元素
        return maxLen - 1;
    }
}

```

【减少内存开销】

* java

```java
class Solution {
    public int longestSubarray(int[] nums) {
        int len = nums.length;
        // len0 以 nums[i] 结尾且含有一个 0 的最长连续子数组长度
        // len1 以 nums[i] 结尾且全为 1 的最长连续子数组长度
        int len0 = (nums[0] == 0) ? 1 : 0;
        int len1 = nums[0];

        int maxLen = 0;
        for (int i = 1; i < len; i++) {
            if(nums[i] == 0){
                len0 = len1 + 1;
                len1 = 0;
            }else{
                len0++;
                len1++;
            }

            if(len0 > maxLen || len1 > maxLen){
                maxLen = Math.max(len0, len1);
            }
        }

        // 必须要删除一个元素
        return maxLen - 1;
    }
}

```

### 最后

如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/

也欢迎加我微信『 **code5bug** 』和 加入我们的「组队打卡」小群。
