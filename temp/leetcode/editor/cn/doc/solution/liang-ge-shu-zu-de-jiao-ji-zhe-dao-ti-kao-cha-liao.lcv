![å“ˆå¸Œè¡¨ï¼š2.ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†.jpg](https://pic.leetcode-cn.com/1658368494-cBiStL-%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9A2.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.jpg)

å…³äºæœ¬é¢˜ï¼Œæˆ‘å½•åˆ¶äº†è®²è§£è§†é¢‘ï¼š[å­¦é€å“ˆå¸Œè¡¨ï¼Œsetä½¿ç”¨æœ‰æŠ€å·§ï¼Leetcodeï¼š349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†](https://www.bilibili.com/video/BV1ba411S7wu)ï¼Œçœ‹è§†é¢‘é…åˆé¢˜è§£ï¼Œäº‹åŠåŠŸå€ã€‚

## æ€è·¯

è¿™é“é¢˜ç›®ï¼Œä¸»è¦è¦å­¦ä¼šä½¿ç”¨ä¸€ç§å“ˆå¸Œæ•°æ®ç»“æ„ï¼Œunordered_setï¼Œè¿™ä¸ªæ•°æ®ç»“æ„å¯ä»¥è§£å†³å¾ˆå¤šç±»ä¼¼çš„é—®é¢˜ã€‚

æ³¨æ„é¢˜ç›®ç‰¹æ„è¯´æ˜ï¼š**è¾“å‡ºç»“æœä¸­çš„æ¯ä¸ªå…ƒç´ ä¸€å®šæ˜¯å”¯ä¸€çš„ï¼Œä¹Ÿå°±æ˜¯è¯´è¾“å‡ºçš„ç»“æœçš„å»é‡çš„ï¼Œ åŒæ—¶å¯ä»¥ä¸è€ƒè™‘è¾“å‡ºç»“æœçš„é¡ºåº**

è¿™é“é¢˜ç”¨æš´åŠ›çš„è§£æ³•æ—¶é—´å¤æ‚åº¦æ˜¯O(n^2)ï¼Œè¿™ç§è§£æ³•é¢è¯•å®˜ä¸€å®šä¸ä¼šæ»¡æ„ï¼Œé‚£çœ‹çœ‹ä½¿ç”¨å“ˆå¸Œæ³•è¿›ä¸€æ­¥ä¼˜åŒ–ã€‚

é‚£ä¹ˆå¯ä»¥å‘ç°ï¼Œè²Œä¼¼ç”¨æ•°ç»„åšå“ˆå¸Œè¡¨å¯ä»¥è§£å†³è¿™é“é¢˜ç›®ï¼ŒæŠŠnums1çš„å…ƒç´ ï¼Œæ˜ å°„åˆ°å“ˆå¸Œæ•°ç»„çš„ä¸‹è¡¨ä¸Šï¼Œç„¶ååœ¨éå†nums2çš„æ—¶å€™ï¼Œåˆ¤æ–­æ˜¯å¦å‡ºç°è¿‡å°±å¯ä»¥äº†ã€‚

ä½†æ˜¯è¦æ³¨æ„ï¼Œä½¿ç”¨æ•°æ®æ¥åšå“ˆå¸Œçš„é¢˜ç›®ï¼Œéƒ½é™åˆ¶äº†æ•°å€¼çš„å¤§å°ï¼Œä¾‹å¦‚åªæœ‰å°å†™å­—æ¯ï¼Œæˆ–è€…æ•°å€¼å¤§å°åœ¨[0- 10000] ä¹‹å†…ç­‰ç­‰ã€‚ è€Œè¿™é“é¢˜ç›®æ²¡æœ‰é™åˆ¶æ•°å€¼çš„å¤§å°ï¼Œå°±æ— æ³•ä½¿ç”¨æ•°ç»„æ¥åšå“ˆå¸Œè¡¨äº†ã€‚

ä¾‹å¦‚è¯´ï¼šå¦‚æœæˆ‘çš„è¾“å…¥æ ·ä¾‹æ˜¯è¿™æ ·çš„ï¼Œ éš¾é“è¦å®šä¹‰ä¸€ä¸ª2äº¿å¤§å°çš„æ•°ç»„æ¥åšå“ˆå¸Œè¡¨ä¹ˆï¼Œ ä¸åŒçš„è¯­è¨€å¯¹æ•°ç»„å®šä¹‰çš„å¤§å°éƒ½æ˜¯æœ‰é™åˆ¶çš„ï¼Œ å³ä½¿æœ‰çš„è¯­è¨€å¯ä»¥å®šä¹‰è¿™ä¹ˆå¤§çš„æ•°ç»„ï¼Œé‚£ä¹Ÿæ˜¯å¯¹å†…å­˜ç©ºé—´é€ æˆäº†éå¸¸å¤§çš„æµªè´¹ã€‚

æ­¤æ—¶å°±è¦ä½¿ç”¨å¦ä¸€ç§ç»“æ„ä½“äº†ï¼Œset ï¼Œå…³äºsetï¼ŒC++ ç»™æä¾›äº†å¦‚ä¸‹ä¸‰ç§å¯ç”¨çš„æ•°æ®ç»“æ„

* std::set
* std::multiset
* std::unordered_set

std::setå’Œstd::multisetåº•å±‚å®ç°éƒ½æ˜¯çº¢é»‘æ ‘ï¼Œstd::unordered_setçš„åº•å±‚å®ç°æ˜¯å“ˆå¸Œè¡¨ï¼Œ ä½¿ç”¨unordered_set è¯»å†™æ•ˆç‡æ˜¯æœ€é«˜çš„ï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦å¯¹æ•°æ®è¿›è¡Œæ’åºï¼Œè€Œä¸”è¿˜ä¸è¦è®©æ•°æ®é‡å¤ï¼Œæ‰€ä»¥é€‰æ‹©unordered_setã€‚

![image.png](https://pic.leetcode-cn.com/1657186593-QCLQoy-image.png)

## ä»£ç 

* 

```
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set; // å­˜æ”¾ç»“æœ
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for (int num : nums2) {
            // å‘ç°nums2çš„å…ƒç´  åœ¨nums_seté‡Œåˆå‡ºç°è¿‡
            if (nums_set.find(num) != nums_set.end()) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

## åè®°

æœ¬é¢˜åé¢ åŠ›æ‰£æ”¹äº† é¢˜ç›®æè¿° å’Œ åå°æµ‹è¯•æ•°æ®ï¼Œå¢æ·»äº† æ•°å€¼èŒƒå›´ï¼š

* 1 <= nums1.length, nums2.length <= 1000
* 0 <= nums1[i], nums2[i] <= 1000

æ‰€ä»¥å°±å¯ä»¥ ä½¿ç”¨æ•°ç»„æ¥åšå“ˆå¸Œè¡¨äº†ï¼Œ å› ä¸ºæ•°ç»„éƒ½æ˜¯ 1000ä»¥å†…çš„ã€‚

å¯¹åº”C++ä»£ç å¦‚ä¸‹ï¼š

* c++

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set; // å­˜æ”¾ç»“æœï¼Œä¹‹æ‰€ä»¥ç”¨setæ˜¯ä¸ºäº†ç»™ç»“æœé›†å»é‡
        int hash[1005] = {0}; // é»˜è®¤æ•°å€¼ä¸º0
        for (int num : nums1) { // nums1ä¸­å‡ºç°çš„å­—æ¯åœ¨hashæ•°ç»„ä¸­åšè®°å½•
            hash[num] = 1;
        }
        for (int num : nums2) { // nums2ä¸­å‡ºç°è¯ï¼Œresultè®°å½•
            if (hash[num] == 1) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

## å…¶ä»–è¯­è¨€ç‰ˆæœ¬

* []

```Java
import java.util.HashSet;
import java.util.Set;

class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {
            return new int[0];
        }
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> resSet = new HashSet<>();
        //éå†æ•°ç»„1
        for (int i : nums1) {
            set1.add(i);
        }
        //éå†æ•°ç»„2çš„è¿‡ç¨‹ä¸­åˆ¤æ–­å“ˆå¸Œè¡¨ä¸­æ˜¯å¦å­˜åœ¨è¯¥å…ƒç´ 
        for (int i : nums2) {
            if (set1.contains(i)) {
                resSet.add(i);
            }
        }
        //å°†ç»“æœå‡ ä½•è½¬ä¸ºæ•°ç»„
        return resSet.stream().mapToInt(x -> x).toArray();
    }
}
```

* []

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return list(set(nums1) & set(nums2))    # ä¸¤ä¸ªæ•°ç»„å…ˆå˜æˆé›†åˆï¼Œæ±‚äº¤é›†åè¿˜åŸä¸ºæ•°ç»„
```

Goï¼š

* []

```go
func intersection(nums1 []int, nums2 []int) []int {
    m := make(map[int]int)
    for _, v := range nums1 {
        m[v] = 1
    }
    var res []int
    // åˆ©ç”¨count>0ï¼Œå®ç°é‡å¤å€¼åªæ‹¿ä¸€æ¬¡æ”¾å…¥è¿”å›ç»“æœä¸­
    for _, v := range nums2 {
        if count, ok := m[v]; ok && count > 0 {
            res = append(res, v)
            m[v]--
        }
    }
    return res
}

//ä¼˜åŒ–ç‰ˆï¼Œåˆ©ç”¨setï¼Œå‡å°‘countç»Ÿè®¡
func intersection(nums1 []int, nums2 []int) []int {
    set:=make(map[int]struct{},0)
    res:=make([]int,0)
    for _,v:=range nums1{
        if _,ok:=set[v];!ok{
            set[v]=struct{}{}
        }
    }
    for _,v:=range nums2{
        //å¦‚æœå­˜åœ¨äºä¸Šä¸€ä¸ªæ•°ç»„ä¸­ï¼Œåˆ™åŠ å…¥ç»“æœé›†ï¼Œå¹¶æ¸…ç©ºè¯¥setå€¼
        if _,ok:=set[v];ok{
            res=append(res,v)
            delete(set, v)
        }
    }
    return res
}
```

* []

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    // æ ¹æ®æ•°ç»„å¤§å°äº¤æ¢æ“ä½œçš„æ•°ç»„
    if(nums1.length < nums2.length) {
        const _ = nums1;
        nums1 = nums2;
        nums2 = _;
    }
    const nums1Set = new Set(nums1);
    const resSet = new Set();
    // for(const n of nums2) {
    //     nums1Set.has(n) && resSet.add(n);
    // }
    // å¾ªç¯ æ¯” è¿­ä»£å™¨å¿«
    for(let i = nums2.length - 1; i >= 0; i--) {
        nums1Set.has(nums2[i]) && resSet.add(nums2[i]);
    }
    return Array.from(resSet);
};
```

* []

```typescript
function intersection(nums1: number[], nums2: number[]): number[] {
    let resSet: Set<number> = new Set(),
        nums1Set: Set<number> = new Set(nums1);
    for (let i of nums2) {
        if (nums1Set.has(i)) {
            resSet.add(i);
        }
    }
    return Array.from(resSet);
};
// ç‰ˆæœ¬äºŒï¼ˆç§€æ“ä½œï¼‰ï¼š
function intersection(nums1: number[], nums2: number[]): number[] {
    return Array.from(new Set(nums1.filter(i => nums2.includes(i))))
};
```

* []

```swift
func intersection(_ nums1: [Int], _ nums2: [Int]) -> [Int] {
    var set1 = Set<Int>()
    var set2 = Set<Int>()
    for num in nums1 {
        set1.insert(num)
    }
    for num in nums2 {
        if set1.contains(num) {
            set2.insert(num)
        }
    }
    return Array(set2)
}
```

* []

```php
class Solution {
    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @return Integer[]
     */
    function intersection($nums1, $nums2) {
        if (count($nums1) == 0 || count($nums2) == 0) {
            return [];
        }
        $counts = [];
        $res = [];
        foreach ($nums1 as $num) {
            $counts[$num] = 1;
        }
        foreach ($nums2 as $num) {
            if (isset($counts[$num])) {
                $res[] = $num;
            }
            unset($counts[$num]);
        }
        
        return $res;
    }
}
```

* []

```rust
use std::collections::HashSet;
impl Solution {
    pub fn intersection(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {
        let mut resultSet: HashSet<i32> = HashSet::with_capacity(1000);
        let nums1Set: HashSet<i32> = nums1.into_iter().collect();
        
        for num in nums2.iter() {
            if nums1Set.contains(num) {
                resultSet.insert(*num);
            }          
        }
        
        let ret: Vec<i32> = resultSet.into_iter().collect();
        ret
    }
}
```

* []

```C
int* intersection1(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){

    int nums1Cnt[1000] = {0};
    int lessSize = nums1Size < nums2Size ? nums1Size : nums2Size;
    int * result = (int *) calloc(lessSize, sizeof(int));
    int resultIndex = 0;
    int* tempNums;
    
    int i;

    /* Calculate the number's counts for nums1 array */
    for(i = 0; i < nums1Size; i ++) {
        nums1Cnt[nums1[i]]++;
    }

    /* Check if the value in nums2 is existing in nums1 count array */
    for(i = 0; i < nums2Size; i ++) {
        if(nums1Cnt[nums2[i]] > 0) {
            result[resultIndex] = nums2[i];
            resultIndex ++;
            /* Clear this count to avoid duplicated value */
            nums1Cnt[nums2[i]] = 0;
        }
    }
    * returnSize = resultIndex;
    return result;
}
```

* []

```scala
object Solution {
  def intersection(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {
    // å¯¼å…¥mutable
    import scala.collection.mutable
    // ä¸´æ—¶Setï¼Œç”¨äºè®°å½•æ•°ç»„1å‡ºç°çš„æ¯ä¸ªå…ƒç´ 
    val tmpSet: mutable.HashSet[Int] = new mutable.HashSet[Int]()
    // ç»“æœSetï¼Œå­˜å‚¨æœ€ç»ˆç»“æœ
    val resSet: mutable.HashSet[Int] = new mutable.HashSet[Int]()
    // éå†nums1ï¼ŒæŠŠæ¯ä¸ªå…ƒç´ æ·»åŠ åˆ°tmpSet
    nums1.foreach(tmpSet.add(_))
    // éå†nums2ï¼Œå¦‚æœåœ¨tmpSetå­˜åœ¨å°±æ·»åŠ åˆ°resSet
    nums2.foreach(elem => {
      if (tmpSet.contains(elem)) {
        resSet.add(elem)
      }
    })
    // å°†ç»“æœè½¬æ¢ä¸ºArrayè¿”å›ï¼Œreturnå¯ä»¥çœç•¥
    resSet.toArray
  }
}
// éªšæ“ä½œ1:
object Solution {
  def intersection(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {
    // å…ˆè½¬ä¸ºSetï¼Œç„¶åå–äº¤é›†ï¼Œæœ€åè½¬æ¢ä¸ºArray
    (nums1.toSet).intersect(nums2.toSet).toArray
  }
}
 // éªšæ“ä½œ2:
object Solution {
  def intersection(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {
    // distinctå»é‡ï¼Œç„¶åå–äº¤é›†
    (nums1.distinct).intersect(nums2.distinct)
  }
}

```

* []

```csharp
 public int[] Intersection(int[] nums1, int[] nums2) {
    if(nums1==null||nums1.Length==0||nums2==null||nums1.Length==0)
    	return new int[0]; //æ³¨æ„æ•°ç»„æ¡ä»¶
    HashSet<int> one = Insert(nums1);
    HashSet<int> two = Insert(nums2);
    one.IntersectWith(two);
    return one.ToArray();
	}
 public HashSet<int> Insert(int[] nums){
    HashSet<int> one = new HashSet<int>();
    foreach(int num in nums){
    	one.Add(num);         
    	}
        return one;
	}

```

**å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ç¨‹åºå‘˜Carlï¼Œç‚¹å‡»[æˆ‘çš„å¤´åƒ](https://programmercarl.com)**ï¼ŒæŸ¥çœ‹åŠ›æ‰£è¯¦ç»†åˆ·é¢˜æ”»ç•¥ï¼Œä½ ä¼šå‘ç°ç›¸è§æ¨æ™šï¼

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**
